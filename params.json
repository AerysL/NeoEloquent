{"name":"Neoeloquent","tagline":"An Eloquent Neo4j Graph Driver","body":"\r\n# NeoEloquent\r\n\r\n[![Build Status](https://travis-ci.org/Vinelab/NeoEloquent.svg?branch=master)](https://travis-ci.org/Vinelab/NeoEloquent)\r\n\r\nNeo4j Graph Eloquent Driver for Laravel 4\r\n\r\n## Quick Reference\r\n\r\n - [Installation](#installation)\r\n - [Configuration](#configuration)\r\n - [Models](#models)\r\n - [Relationships](#relationships)\r\n - [Edges](#edges)\r\n - [Only in Neo](#only-in-neo)\r\n - [Aggregates](#aggregates)\r\n - [Things To Avoid](#avoid)\r\n\r\n## Installation\r\n\r\nAdd the package to your `composer.json` and run `composer update`.\r\n\r\n```json\r\n{\r\n    \"require\": {\r\n        \"vinelab/neoeloquent\": \"*\"\r\n    }\r\n}\r\n```\r\n\r\nAdd the service provider in `app/config/app.php`:\r\n\r\n```php\r\n'Vinelab\\NeoEloquent\\NeoEloquentServiceProvider',\r\n```\r\n\r\nThe service provider will register all the required classes for this package and will also alias\r\nthe `Model` class to `NeoEloquent` so you can simply `extend NeoEloquent` in your models.\r\n\r\n## Configuration\r\nin `app/config/database.php` or in case of an environment-based configuration `app/config/[env]/database.php`\r\nmake `neo4j` your default connection:\r\n\r\n```php\r\n'default' => 'neo4j',\r\n```\r\n\r\nAdd the connection defaults:\r\n\r\n```php\r\n'connections' => [\r\n    'neo4j' => [\r\n        'driver' => 'neo4j',\r\n        'host'   => 'localhost',\r\n        'port'   => '7474'\r\n    ]\r\n]\r\n```\r\n\r\n### Documentation\r\n\r\n## Models\r\n\r\n- [Node Labels](#namespaced-models)\r\n- [Soft Deleting](#soft-deleting)\r\n\r\n```php\r\nclass User extends NeoEloquent {}\r\n```\r\n\r\nAs simple as it is, NeoEloquent will generate the default node label from the class name,\r\nin this case it will be `:User`. Read about [node labels here](http://docs.neo4j.org/chunked/stable/rest-api-node-labels.html)\r\n\r\n### Namespaced Models\r\nWhen you use namespaces with your models the label will consider the full namespace.\r\n\r\n```php\r\nnamespace Vinelab\\Cms;\r\n\r\nclass Admin extends NeoEloquent { }\r\n```\r\n\r\nThe generated label from that relationship will be `VinelabCmsAdmin`, this is necessary to make sure\r\nthat labels do not clash in cases where we introduce another  `Admin` instance like\r\n`Vinelab\\Blog\\Admin` then things gets messy with `:Admin` in the database.\r\n\r\n### Custom Node Labels\r\n\r\nYou may specify the label(s) you wish to be used instead of the default generated, they are also\r\ncase sensitive so they will be stored as put here.\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    protected $label = 'User'; // or array('User', 'Fan')\r\n\r\n    protected $fillable = ['name', 'email'];\r\n}\r\n\r\n$user = User::create(['name' => 'Some Name', 'email' => 'some@email.com']);\r\n```\r\n\r\nNeoEloquent has a fallback support for the `$table` variable that will be used if found and there was no `$label` defined on the model.\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    protected $table = 'User';\r\n\r\n}\r\n```\r\n\r\nDo not worry about the labels formatting, You may specify them as `array('Label1', 'Label2')` or separate them by a column `:` and prepending them with a `:` is optional.\r\n\r\n### Soft Deleting\r\n\r\nTo enable soft deleting you'll need to `use Vinelab\\NeoEloquent\\Eloquent\\SoftDeletingTrait`\r\ninstead of `Illuminate\\Database\\Eloquent\\SoftDeletingTrait` and just like Eloquent you'll need the `$dates` in your models as follows:\r\n\r\n```php\r\nuse Vinelab\\NeoEloquent\\Eloquent\\SoftDeletingTrait;\r\n\r\nclass User extends NeoEloquent {\r\n\r\n    use SoftDeletingTrait;\r\n\r\n    protected $dates = ['deleted_at'];\r\n\r\n}\r\n```\r\n\r\n## Relationships\r\n\r\n- [One-To-One](#one-to-one)\r\n- [One-To-Many](#one-to-many)\r\n- [Many-To-Many](#many-to-many)\r\n- [Polymorphic](#polymorphic)\r\n\r\nLet's go through some examples of relationships between Nodes.\r\n\r\n### One-To-One\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function phone()\r\n    {\r\n        return $this->hasOne('Phone');\r\n    }\r\n```\r\nThis represents an `OUTGOING` relationship direction from the `:User` node to a `:Phone`.\r\n\r\n##### Saving\r\n\r\n```php\r\n$phone = new Phone(['code' => 961, 'number' => '98765432'])\r\n$relation = $user->phone()->save($phone);\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (user:`User`)\r\nWHERE id(user) = 1\r\nCREATE (user)-[:PHONE]->(phone:`Phone` {code: 961, number: '98765432', created_at: 7543788, updated_at: 7543788})\r\nRETURN phone;\r\n```\r\n\r\n##### Defining The Inverse Of This Relation\r\n\r\n```php\r\nclass Phone extends NeoEloquent {\r\n\r\n    public function user()\r\n    {\r\n        return $this->belongsTo('User');\r\n    }\r\n}\r\n```\r\n\r\nThis represents an `INCOMING` relationship direction from\r\nthe `:User` node to this `:Phone` node.\r\n\r\n##### Associating Models\r\n\r\nDue to the fact that we do not deal with **foreign keys**, in our case it is much\r\nmore than just setting the foreign key attribute on the parent model. In Neo4j (and Graph in general) a relationship is an entity itself that can also have attributes of its own, hence the introduction of\r\n[**Edges**](#Edges)\r\n\r\n> *Note:* Associated models does not persist relations automatically when calling `associate()`.\r\n\r\n```php\r\n$account = Account::find(1986);\r\n\r\n// $relation will be Vinelab\\NeoEloquent\\Eloquent\\Edges\\EdgeIn\r\n$relation = $user->account()->associate($account);\r\n\r\n// Save the relation\r\n$relation->save();\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (account:`Account`), (user:`User`)\r\nWHERE id(account) = 1986 AND id(user) = 9862\r\nMERGE (account)<-[rel_user_account:ACCOUNT]-(user)\r\nRETURN rel_user_account;\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (phone:Phone) (phone)<-[:PHONE]-(user:User)\r\nWHERE id(phone) = 1006\r\nRETURN user;\r\n```\r\n\r\n### One-To-Many\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function posts()\r\n    {\r\n        return $this->hasMany('Post', 'POSTED');\r\n    }\r\n}\r\n```\r\n\r\nThis represents an `OUTGOING` relationship direction\r\nfrom the `:User` node to the `:Post` node.\r\n\r\n```php\r\n$user = User::find(1);\r\n$post = new Post(['title' => 'The Title', 'body' => 'Hot Body']);\r\n$user->posts()->save($post);\r\n```\r\n\r\nSimilar to `One-To-One` relationships the returned value from a `save()` statement is an\r\n`Edge[In|Out]`\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (user:`User`)\r\nWHERE id(user) = 1\r\nCREATE (user)-[rel_user_post:POSTED]->(post:`Post` {title: 'The Title', body: 'Hot Body', created_at: '15-05-2014', updated_at: '15-05-2014'})\r\nRETURN rel_user_post;\r\n```\r\n\r\n##### Defining The Inverse Of This Relation\r\n\r\n```php\r\nclass Post extends NeoEloquent {\r\n\r\n    public function author()\r\n    {\r\n        return $this->belongsTo('User', 'POSTED');\r\n    }\r\n}\r\n```\r\n\r\nThis represents an `INCOMING` relationship direction from\r\nthe `:User` node to this `:Post` node.\r\n\r\n### Many-To-Many\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function followers()\r\n    {\r\n        return $this->belongsToMany('User', 'FOLLOWS');\r\n    }\r\n}\r\n```\r\n\r\nThis represents an `OUTGOING` relationship between a `:User` node and another `:User`.\r\n\r\n```php\r\n$jd = User::find(1012);\r\n$mc = User::find(1013);\r\n```\r\n\r\n`$jd` follows `$mc`:\r\n\r\n```php\r\n$jd->followers()->save($mc);\r\n```\r\n\r\nOr using the `attach()` method:\r\n\r\n```php\r\n$jd->followers()->attach($mc);\r\n// Or..\r\n$jd->followers()->attach(1); // 1 being the id of $mc ($mc->getKey())\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (user:`User`), (followers:`User`)\r\nWHERE id(user) = 1012 AND id(followers) = 1013\r\nCREATE (user)-[:FOLLOWS]->(followers)\r\nRETURN rel_follows;\r\n```\r\n\r\n`$mc` follows `$jd` back:\r\n\r\n```php\r\n$mc->followers()->save($jd);\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (user:`User`), (followers:`User`)\r\nWHERE id(user) = 1013 AND id(followers) = 1012\r\nCREATE (user)-[rel_user_followers:FOLLOWS]->(followers)\r\nRETURN rel_follows;\r\n```\r\n\r\nget the followers of `$jd`\r\n\r\n```php\r\n$followers = $jd->followers;\r\n```\r\n\r\nThe Cypher performed by this statement will be as follows:\r\n\r\n```\r\nMATCH (user:`User`), (followers:`User`), (user)-[rel_user_followers:FOLLOWS]-(followers)\r\nWHERE id(user) = 1012\r\nRETURN rel_follows;\r\n```\r\n\r\n### Dynamic Properties\r\n\r\n```php\r\nclass Phone extends Eloquent {\r\n\r\n    public function user()\r\n    {\r\n        return $this->belongsTo('User');\r\n    }\r\n\r\n}\r\n\r\n$phone = Phone::find(1006);\r\n$user = $phone->user;\r\n// or getting an attribute out of the related model\r\n$name = $phone->user->name;\r\n```\r\n\r\n### Polymorphic\r\n\r\nThe concept behind Polymocrphic relations is purely relational to the bone but when it comes\r\nto graph we are representing it as a [HyperEdge](http://docs.neo4j.org/chunked/stable/cypher-cookbook-hyperedges.html).\r\n\r\nHyper edges involves three models, the **parent** model, **hyper** model and **related** model\r\nrepresented in the following figure:\r\n\r\n![HyperEdges](https://googledrive.com/host/0BznzZ2lBbT0cLW9YcjNldlJkcXc/HyperEdge.png \"HyperEdges\")\r\n\r\nSimilarly in code this will be represented by three models `User` `Comment` and `Post`\r\nwhere a `User` with id 1 posts a `Post` and a `User` with id 6 `COMMENTED` a `Comment` `ON` that `Post`\r\nas follows:\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function comments($morph = null)\r\n    {\r\n        return $this->hyperMorph($morph, 'Comment', 'COMMENTED', 'ON');\r\n    }\r\n\r\n}\r\n```\r\n\r\nIn order to keep things simple but still involving the three models we will have to pass the\r\n`$morph` which is any `commentable` model, in our case it's either a `Video` or a `Post` model.\r\n\r\n> **Note:** Make sure to have it defaulting to `null` so that we can Dynamicly or Eager load\r\nwith `$user->comments` later on.\r\n\r\nCreating a `Comment` with the `create()` method.\r\n\r\n```php\r\n$user = User::find(6);\r\n$post = Post::find(2);\r\n\r\n$user->comments($post)->create(['text' => 'Totally agree!', 'likes' => 0, 'abuse' => 0]);\r\n```\r\n\r\nAs usual we will have returned an Edge, but this time it's not directed it is an instance of\r\n`HyperEdge`, read more about [HyperEdges here](#hyperedge).\r\n\r\nOr you may save a Comment instance:\r\n\r\n```php\r\n$comment = new Comment(['text' => 'Magnificent', 'likes' => 0, 'abuse' => 0]);\r\n\r\n$user->comments($post)->save($comment);\r\n```\r\n\r\nAlso all the functionalities found in a `BelongsToMany` relationship are supported like\r\nattaching models by Ids:\r\n\r\n```php\r\n$user->comments($post)->attach([$id, $otherId]);\r\n```\r\n\r\nOr detaching models:\r\n\r\n```php\r\n$user->comments($post)->detach($comment); // or $comment->id\r\n```\r\n\r\nSync too:\r\n\r\n```php\r\n$user->comments($post)->sync([$id, $otherId, $someId]);\r\n```\r\n\r\n#### Retrieving Polymorphic Relations\r\n\r\nFrom our previous example we will use the `Video` model to retrieve their comments:\r\n\r\n```php\r\nclass Video extends NeoEloquent {\r\n\r\n    public function comments()\r\n    {\r\n        return $this->morphMany('Comment', 'ON');\r\n    }\r\n\r\n}\r\n```\r\n\r\n##### Dynamicly Loading Morph Model\r\n\r\n```php\r\n$video = Video::find(3);\r\n$comments = $video->comments;\r\n```\r\n\r\n##### Eager Loading Morph Model\r\n\r\n```php\r\n$video = Video::with('comments')->find(3);\r\nforeach ($video->comments as $comment)\r\n{\r\n    //\r\n}\r\n```\r\n\r\n#### Retrieving The Inverse of a Polymorphic Relation\r\n\r\n```php\r\nclass Comment extends NeoEloquent {\r\n\r\n    public function commentable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n\r\n}\r\n```\r\n\r\n```php\r\n$postComment = Comment::find(7);\r\n$post = $comment->commentable;\r\n\r\n$videoComment = Comment::find(5);\r\n$video = $comment->commentable;\r\n\r\n// You can also eager load them\r\nComment::with('commentable')->get();\r\n```\r\n\r\nYou may also specify the type of morph you would like returned:\r\n\r\n```php\r\nclass Comment extends NeoEloquent {\r\n\r\n    public function post()\r\n    {\r\n        return $this->morphTo('Post', 'ON');\r\n    }\r\n\r\n    public function video()\r\n    {\r\n        return $this->morphTo('Video', 'ON');\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### Polymorphic Relations In Short\r\n\r\nTo drill things down here's how our three models involved in a Polymorphic relationship connect:\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function comments($morph = null)\r\n    {\r\n        return $this->hyperMorph($morph, 'Comment', 'COMMENTED', 'ON');\r\n    }\r\n\r\n}\r\n```\r\n\r\n```php\r\nclass Post extends NeoEloquent { // Video is the same as this one\r\n\r\n    public function comments()\r\n    {\r\n        return $this->morphMany('Comment', 'ON');\r\n    }\r\n\r\n}\r\n```\r\n\r\n```php\r\nclass Comment extends NeoEloquent {\r\n\r\n    public function commentable()\r\n    {\r\n        return $this->morphTo();\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n### Eager Loading\r\n\r\n```php\r\nclass Book extends Eloquent {\r\n\r\n    public function author()\r\n    {\r\n        return $this->belongsTo('Author');\r\n    }\r\n}\r\n```\r\n\r\nLoading authors with their books with the least performance overhead possible.\r\n\r\n```php\r\nforeach (Book::with('author')->get() as $book)\r\n{\r\n    echo $book->author->name;\r\n}\r\n```\r\n\r\nOnly two Cypher queries will be run in the loop above:\r\n\r\n```\r\nMATCH (book:`Book`) RETURN *;\r\n\r\nMATCH (book:`Book`), (book)<-[:WROTE]-(author:`Author`) WHERE id(book) IN [1, 2, 3, 4, 5, ...] RETURN book, author;\r\n```\r\n\r\n## Edges\r\n\r\n- [EdgeIn](#edgein)\r\n- [EdgeOut](#edgeout)\r\n- [HyperEdge](#hyperedge)\r\n- [Working with Edges](#working-with-edges)\r\n- [Edge Attributes](#edge-attributes)\r\n\r\n### Introduction\r\n\r\nDue to the fact that relationships in Graph are much different than other database types so\r\nwe will have to handle them accordingly. Relationships have directions that can vary between\r\n**In** and **Out** respectively towards the parent node.\r\n\r\n#### EdgeIn\r\n\r\nRepresents an `INCOMING` direction relationship from the related model towards the parent model.\r\n\r\n```php\r\nclass Location extends NeoEloquent {\r\n\r\n    public function user()\r\n    {\r\n        return $this->belongsTo('User', 'LOCATED_AT');\r\n    }\r\n\r\n}\r\n```\r\n\r\nTo associate a `User` to a `Location`:\r\n\r\n```php\r\n$location = Location::find(1922);\r\n$user = User::find(3876);\r\n$relation = $location->associate($user);\r\n```\r\n\r\nwhich in Cypher land will map to `(:Location)<-[:LOCATED_AT]-(:User)` and `$relation`\r\nbeing an instance of `EdgeIn` representing an incoming relationship towards the parent.\r\n\r\nAnd you can still access the models from the edge:\r\n\r\n```php\r\n$relation = $location->associate($user);\r\n$location = $relation->parent();\r\n$user = $relation->related();\r\n```\r\n\r\n#### EdgeOut\r\n\r\nRepresents an `OUTGOING` direction relationship from the parent model to the related model.\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function posts()\r\n    {\r\n        return $this->hasMany('Post', 'POSTED');\r\n    }\r\n\r\n}\r\n```\r\n\r\nTo save an outgoing edge from `:User` to `:Post` it goes like:\r\n\r\n```php\r\n$post = new Post(['...']);\r\n$posted = $user->posts()->save($post);\r\n```\r\n\r\nWhich in Cypher would be `(:User)-[:POSTED]->(:Post)` and `$posted` being the `EdgeOut` instance.\r\n\r\nAnd fetch the related models:\r\n\r\n```php\r\n$edge = $user->posts()->save($post);\r\n$user = $edge->parent();\r\n$post = $edge->related();\r\n```\r\n\r\n#### HyperEdge\r\n\r\nThis edge comes as a result of a [Polymorphic Relation](#polymorphic) representing an edge involving\r\ntow other edges **left** and **right** that can be accessed through the `left()` and `right()` methods.\r\n\r\nThis edge is treated a bit different than the others since it is not a direct relationship\r\nbetween two models which means it has no specific direction.\r\n\r\n```php\r\n$edge = $user->comments($post)->attach($comment);\r\n// Access the left and right edges\r\n$left = $edge->left();\r\n$user = $left->parent();\r\n$comment = $left->related();\r\n\r\n$right = $edge->right();\r\n$comment = $right->parent();\r\n$post = $right->related();\r\n```\r\n\r\n### Working With Edges\r\n\r\nAs stated earlier **Edges** are entities to Graph unlike *SQL* where they are a matter of a\r\nforeign key having the value of the parent model as an attribute on the belonging model or in\r\n*Documents* where they are either embeds or ids as references. So we developed them to be *light\r\nmodels* which means you can work with them as if you were working with an `Eloquent` instance - to a certain extent,\r\nexcept [HyperEdges](#hyperedges).\r\n\r\n```php\r\n// Create a new relationship\r\n$relation = $location->associate($user); // Vinelab\\NeoEloquent\\Eloquent\\Edges\\EdgeIn\r\n\r\n// Save the relationship to the database\r\n$relation->save(); // true\r\n```\r\n\r\nIn the case of a `HyperEdge` you can access all three models as follows:\r\n\r\n```php\r\n$edge    = $user->comments($post)->save($comment);\r\n$user    = $edge->parent();\r\n$comment = $edge->hyper();\r\n$post    = $edge->related();\r\n```\r\n\r\n#### Edge Attributes\r\n\r\nBy default, edges will have the timestamps `created_at` and `updated_at` automatically set and updated **only if** timestamps are enabled by setting `$timestamps` to `true`\r\non the parent model.\r\n\r\n```php\r\n$located_at = $location->associate($user);\r\n$located_at->since = 1966;\r\n$located_at->present = true;\r\n$located_at->save();\r\n\r\n// $created_at and $updated_at are Carbon\\Carbon instances\r\n$created_at = $located_at->created_at;\r\n$updated_at = $located_at->updated_at;\r\n```\r\n\r\n##### Retrieve an Edge from a Relation\r\n\r\nThe same way an association will create an `EdgeIn` relationship we can retrieve\r\nthe edge between two models by calling the `edge($model)` method on the `belongsTo`\r\nrelationship.\r\n\r\n```php\r\n$location = Location::find(1892);\r\n$edge = $location->user()->edge();\r\n```\r\n\r\nYou may also specify the model at the other side of the edge.\r\n\r\n> Note: By default NeoEloquent will try to pefrorm the `$location->user` internally to figure\r\nout the related side of the edge based on the relation function name, in this case it's\r\n`user()`.\r\n\r\n```php\r\n$location = Location::find(1892);\r\n$edge = $location->user()->edge($location->user);\r\n```\r\n\r\n## Only in Neo\r\n\r\n- [CreateWith](#createwith)\r\n\r\nHere you will find NeoEloquent-specific methods and implementations that with the\r\nwonderful Eloquent methods would make working with Graph and Neo4j a blast!\r\n\r\n### CreateWith\r\n\r\n- [Creating Relations](#creating-new-records-and-relations)\r\n- [Attaching Relations](#attaching-existing-records-as-relations)\r\n\r\nThis method will \"kind of\" fill the gap between relational and document databases,\r\nit allows the creation of multiple related models with one database hit.\r\n\r\n#### Creating New Records and Relations\r\n\r\nHere's an example of creating a post with attached photos and videos:\r\n\r\n```php\r\nclass Post extends NeoEloquent {\r\n\r\n    public function photos()\r\n    {\r\n        return $this->hasMany('Photo', 'PHOTO');\r\n    }\r\n\r\n    public function videos()\r\n    {\r\n        return $this->hasMany('Video', 'VIDEO');\r\n    }\r\n}\r\n```\r\n\r\n```php\r\n\r\nPost::createWith(['title' => 'the title', 'body' => 'the body'], [\r\n    'photos' => [\r\n        [\r\n            'url'      => 'http://url',\r\n            'caption'  => '...',\r\n            'metadata' => '...'\r\n        ],\r\n        [\r\n            'url' => 'http://other.url',\r\n            'caption' => 'the bay',\r\n            'metadata' => '...'\r\n        ]\r\n    ],\r\n\r\n    'videos' => [\r\n        'title' => 'Boats passing us by',\r\n        'description' => '...'\r\n    ]\r\n]);\r\n```\r\n\r\n> The keys `photos` and `videos` must be the same as the relation method names in the\r\n`Post` model.\r\n\r\nThe Cypher query performed by the example above is:\r\n\r\n```\r\nCREATE (post:`Post` {title: 'the title', body: 'the body'}),\r\n(post)-[:PHOTO]->(:`Photo` {url: 'http://url', caption: '...', metadata: '...'}),\r\n(post)-[:PHOTO]->(:`Photo` {url: 'http://other', caption: 'the bay', metadata: '...'}),\r\n(post)-[:VIDEO]->(:`Video` {title: 'Boats passing us by', description: '...'});\r\n```\r\n\r\nWe will get the nodes created with their relations as such:\r\n\r\n![CreateWith](https://googledrive.com/host/0BznzZ2lBbT0cLW9YcjNldlJkcXc/createWith-preview.db.png \"CreateWith\")\r\n\r\nYou may also mix models and attributes as relation values but it is not necessary\r\nsince NeoEloquent will pass the provided attributes through the `$fillable`\r\nfilter pipeline:\r\n\r\n```php\r\n$videos = new Video(['title' => 'foo', 'description' => 'bar']);\r\nPost::createWith($info, compact('videos'));\r\n```\r\n\r\nYou may also use a single array of attributes as such:\r\n\r\n```php\r\nclass User extends NeoEloquent {\r\n\r\n    public function account()\r\n    {\r\n        return $this->hasOne('Account');\r\n    }\r\n}\r\n\r\nUser::createWith(['name' => 'foo'], ['account' => ['guid' => 'bar', 'email' => 'some@mail.net']]);\r\n```\r\n\r\n#### Attaching Existing Records as Relations\r\n\r\n`createWith` is intelligent enough to know the difference when you pass an existing model,\r\na model Id or new records that you need to create which allows mixing new records with existing ones.\r\n\r\n```php\r\nclass Post extends NeoEloquent {\r\n\r\n    public function tags()\r\n    {\r\n        return $this->hasMany('Tag', 'TAG');\r\n    }\r\n}\r\n```\r\n\r\n```php\r\n$tag1 = Tag::create(['title' => 'php']);\r\n$tag2 = Tag::create(['title' => 'dev']);\r\n\r\n$post = Post::createWith(['title' => 'foo', 'body' => 'bar'], ['tags' => [$tag1, $tag2]]);\r\n```\r\n\r\nAnd we will get the `Post` related to the existing `Tag` nodes.\r\n\r\nOr using the `id` of the model:\r\n\r\n```php\r\nPost::createWith(['title' => 'foo', 'body' => 'bar'], ['tags' => 1, 'privacy' => 2]);\r\n```\r\n\r\nThe Cypher for the query that attaches records would be:\r\n\r\n```\r\nCREATE (post:`Post` {title: 'foo', 'body' => 'bar'})\r\nWITH post\r\nMATCH (tag:`Tag`)\r\nWHERE id(tag) IN [1, 2]\r\nCREATE (post)-[:TAG]->(tag);\r\n```\r\n\r\n## Aggregates\r\n\r\nIn addition to the Eloquent builder aggregates, NeoEloquent also has support for\r\nNeo4j specific aggregates like *percentile* and *standard deviation*, keeping the same\r\nfunction names for convenience.\r\nCheck [the docs](http://docs.neo4j.org/chunked/stable/query-aggregation.html) for more.\r\n\r\n> `table()` represents the label of the model\r\n\r\n```\r\n$users = DB::table('User')->count();\r\n\r\n$distinct = DB::table('User')->countDistinct('points');\r\n\r\n$price = DB::table('Order')->max('price');\r\n\r\n$price = DB::table('Order')->min('price');\r\n\r\n$price = DB::table('Order')->avg('price');\r\n\r\n$total = DB::table('User')->sum('votes');\r\n\r\n$disc = DB::table('User')->percentileDisc('votes', 0.2);\r\n\r\n$cont = DB::table('User')->percentileCont('votes', 0.8);\r\n\r\n$deviation = DB::table('User')->stdev('sex');\r\n\r\n$population = DB::table('User')->stdevp('sex');\r\n\r\n$emails = DB::table('User')->collect('email');\r\n```\r\n\r\n## Changelog\r\nCheck the [Releases](https://github.com/Vinelab/NeoEloquent/releases) for details.\r\n\r\n## Avoid\r\n\r\nHere are some constraints and Graph-specific gotchas, a list of features that are either not supported or not recommended.\r\n\r\n### JOINS :confounded:\r\n\r\n- They make no sense for Graph, plus Graph hates them!\r\nWhich makes them unsupported on purpose. If migrating from an `SQL`-based app\r\nthey will be your boogie monster.\r\n\r\n### Pivot Tables in Many-To-Many Relationships\r\nThis is not supported, instead we will be using [Edges](#edges) to work with relationships between models.\r\n\r\n### Nested Arrays and Objects\r\n\r\n- Due to the limitations imposed by the objects map types that can be stored in a single,\r\nyou can never have nested *arrays* or *objects* in a single model,\r\nmake sure it's flat. *Example:*\r\n\r\n```php\r\n// Don't\r\nUser::create(['name' => 'Some Name', 'location' => ['lat' => 123, 'lng'=> -123 ] ]);\r\n```\r\n\r\nCheck out the [createWith()](#createwith) method on how you can achieve this in a Graph way.\r\n\r\n## Tests\r\n\r\n- install a Neo4j instance and run it with the default configuration `localhost:7474`\r\n- make sure the database graph is empty to avoid conflicts\r\n- after running `composer install` there should be `/vendor/bin/phpunit`\r\n- run `./vendor/bin/phpunit` after making sure that the Neo4j instance is running\r\n\r\n> Tests marked as incomplete means they are either known issues or non-supported features,\r\ncheck included messages for more info.\r\n","google":"UA-54103471-1","note":"Don't delete this file! It's used internally to help with page regeneration."}